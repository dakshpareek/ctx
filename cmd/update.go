package cmd

import (
	"fmt"

	"github.com/spf13/cobra"

	"github.com/dakshpareek/ctx/internal/display"
	"github.com/dakshpareek/ctx/internal/index"
	"github.com/dakshpareek/ctx/internal/types"
)

func newUpdateCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "update",
		Short: "Mark skeletons as current after you save AI updates",
		Long: `Run this after saving skeleton updates generated by your AI assistant.

ctx update will:
  1. Recalculate skeleton hashes
  2. Mark matching entries as current
  3. Highlight remaining work that still needs attention`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runUpdate()
		},
	}

	return cmd
}

func runUpdate() error {
	_, indexPath, err := ensureWorkspace(true)
	if err != nil {
		return err
	}

	statsBefore, err := loadIndexStats(indexPath)
	if err != nil {
		return err
	}

	if err := runValidate(validateOptions{fix: true}); err != nil {
		return err
	}

	statsAfter, err := loadIndexStats(indexPath)
	if err != nil {
		return err
	}

	fmt.Println()
	fmt.Println(display.Bold("Update summary:"))
	fmt.Printf("  • Current: %d → %d\n", statsBefore.Current, statsAfter.Current)
	fmt.Printf("  • Stale: %d → %d\n", statsBefore.Stale, statsAfter.Stale)
	fmt.Printf("  • Missing: %d → %d\n", statsBefore.Missing, statsAfter.Missing)
	fmt.Printf("  • Pending: %d → %d\n", statsBefore.PendingGeneration, statsAfter.PendingGeneration)

	remaining := statsAfter.Stale + statsAfter.Missing + statsAfter.PendingGeneration
	if remaining == 0 {
		fmt.Println(display.Success("All caught up! Run 'ctx ask' after your next code changes."))
	} else {
		fmt.Println(display.Info("Remaining work detected. Run 'ctx ask' to generate prompts for the files above."))
	}

	return nil
}

func loadIndexStats(indexPath string) (types.IndexStats, error) {
	idx, err := index.LoadIndex(indexPath)
	if err != nil {
		return types.IndexStats{}, &types.Error{Code: types.ExitCodeData, Err: err}
	}

	return idx.Stats, nil
}
